---
# Main playbook to configure infrastructure provisioned by Terraform
# Triggered by EDA rulebook when Terraform posts infrastructure_provisioned event

- name: Display Terraform Event Context
  hosts: localhost
  connection: local
  gather_facts: no
  become: no
  
  tasks:
    - name: Display Terraform context
      debug:
        msg:
          - "========================================="
          - "Terraform Infrastructure Configuration"
          - "========================================="
          - "Workspace: {{ terraform_workspace }}"
          - "Organization: {{ terraform_organization }}"
          - "Run ID: {{ terraform_run_id }}"
          - "VPC ID: {{ vpc_id }}"
          - "VPC CIDR: {{ vpc_cidr }}"
          - "Region: {{ aws_region }}"
          - "Environment: {{ environment }}"
          - "Instance Count: {{ instances | length }}"
          - "========================================="
    
    - name: Debug Vault environment variables
      debug:
        msg:
          - "VAULT_ADDR: {{ lookup('env', 'VAULT_ADDR') }}"
          - "VAULT_NAMESPACE (env): {{ lookup('env', 'VAULT_NAMESPACE') }}"
          - "VAULT_NAMESPACE (var): {{ vault_namespace }}"
          - "VAULT_ROLE_ID: {{ lookup('env', 'VAULT_ROLE_ID')[:8] }}..."
          - "VAULT_SECRET_ID: {{ 'SET' if lookup('env', 'VAULT_SECRET_ID') else 'NOT SET' }}"

    - name: Authenticate to HCP Vault using AppRole
      uri:
        url: "{{ lookup('env', 'VAULT_ADDR') | regex_replace('/$', '') }}/v1/auth/approle/login"
        method: POST
        body_format: json
        headers:
          X-Vault-Namespace: "{{ vault_namespace }}"
        body:
          role_id: "{{ lookup('env', 'VAULT_ROLE_ID') }}"
          secret_id: "{{ lookup('env', 'VAULT_SECRET_ID') }}"
        status_code: 200
      register: vault_login
      no_log: false
    
    - name: Set Vault token fact
      set_fact:
        vault_token: "{{ vault_login.json.auth.client_token }}"
      no_log: true
    
    - name: Fetch application secrets from HCP Vault
      uri:
        url: "{{ lookup('env', 'VAULT_ADDR') | regex_replace('/$', '') }}/v1/secret/data/applications/demo-app"
        method: GET
        headers:
          X-Vault-Token: "{{ vault_token }}"
          X-Vault-Namespace: "{{ vault_namespace }}"
        status_code: 200
      register: app_secrets
      no_log: true
    
    - name: Set application secrets as facts
      set_fact:
        database_url: "{{ app_secrets.json.data.data.database_url }}"
        api_key: "{{ app_secrets.json.data.data.api_key }}"
      no_log: true
    
    - name: Build in-memory inventory from Terraform event
      add_host:
        name: "{{ item.name }}"
        groups: 
          - app_servers
          - aws_ec2
        ansible_host: "{{ item.private_ip }}"
        instance_id: "{{ item.id }}"
        public_ip: "{{ item.public_ip }}"
        subnet_id: "{{ item.subnet_id }}"
        ansible_user: "ec2-user"
        ansible_ssh_private_key_file: "~/.ssh/demo-key.pem"
        ansible_ssh_common_args: "-o StrictHostKeyChecking=no"
      loop: "{{ instances }}"
      loop_control:
        label: "{{ item.name }}"
    
    - name: Wait for instances to be ready
      wait_for:
        host: "{{ item.public_ip }}"
        port: 22
        delay: 10
        timeout: 300
        state: started
      loop: "{{ instances }}"
      loop_control:
        label: "{{ item.name }}"

- name: Configure EC2 Instances
  hosts: app_servers
  gather_facts: yes
  become: yes
  
  vars:
    vault_token: "{{ hostvars['localhost']['vault_token'] }}"
    vault_address: "{{ lookup('env', 'VAULT_ADDR') | regex_replace('/$', '') }}"
    vault_namespace: "{{ vault_namespace }}"
    database_url: "{{ hostvars['localhost']['database_url'] }}"
    api_key: "{{ hostvars['localhost']['api_key'] }}"
  
  tasks:
    - name: Display instance information
      debug:
        msg:
          - "Configuring: {{ inventory_hostname }}"
          - "Instance ID: {{ instance_id }}"
          - "Private IP: {{ ansible_host }}"
          - "Public IP: {{ public_ip }}"
    
    - name: Update system packages
      yum:
        name: '*'
        state: latest
      register: yum_update
      retries: 3
      delay: 10
    
    - name: Install required packages
      yum:
        name:
          - docker
          - python3
          - python3-pip
          - git
          - vim
          - htop
          - jq
          - nc
        state: present
    
    - name: Start and enable Docker
      systemd:
        name: docker
        state: started
        enabled: yes
    
    - name: Add ec2-user to docker group
      user:
        name: ec2-user
        groups: docker
        append: yes
    
    - name: Create application directory
      file:
        path: /opt/demo-app
        state: directory
        mode: '0755'
        owner: ec2-user
        group: ec2-user
    
    - name: Create configuration directory
      file:
        path: /etc/demo-app
        state: directory
        mode: '0755'
    
    - name: Deploy application configuration
      copy:
        content: |
          # Demo Application Configuration
          # Generated by Ansible from Terraform event
          
          # Terraform Context
          TERRAFORM_RUN_ID={{ hostvars['localhost']['terraform_run_id'] }}
          TERRAFORM_WORKSPACE={{ hostvars['localhost']['terraform_workspace'] }}
          
          # Infrastructure Details
          VPC_ID={{ hostvars['localhost']['vpc_id'] }}
          AWS_REGION={{ hostvars['localhost']['aws_region'] }}
          ENVIRONMENT={{ hostvars['localhost']['environment'] }}
          
          # Instance Details
          INSTANCE_ID={{ instance_id }}
          PRIVATE_IP={{ ansible_host }}
          PUBLIC_IP={{ public_ip }}
          
          # Application Secrets (from HCP Vault)
          DATABASE_URL={{ database_url }}
          API_KEY={{ api_key }}
        dest: /etc/demo-app/config.env
        mode: '0600'
        owner: root
        group: root
    
    - name: Create application service file
      copy:
        content: |
          [Unit]
          Description=Demo Application
          After=docker.service
          Requires=docker.service
          
          [Service]
          Type=simple
          User=ec2-user
          EnvironmentFile=/etc/demo-app/config.env
          ExecStart=/usr/bin/docker run --rm --name demo-app \
            -p 8080:8080 \
            -e DATABASE_URL=${DATABASE_URL} \
            -e API_KEY=${API_KEY} \
            -e VPC_ID=${VPC_ID} \
            -e TERRAFORM_RUN_ID=${TERRAFORM_RUN_ID} \
            quay.io/redhat-demo/sample-app:latest
          ExecStop=/usr/bin/docker stop demo-app
          Restart=always
          RestartSec=10
          
          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/demo-app.service
        mode: '0644'
      notify: Reload systemd
    
    - name: Create validation script
      copy:
        content: |
          #!/bin/bash
          # Validation script for demo application
          
          echo "Validating configuration..."
          
          # Check if config file exists
          if [ ! -f /etc/demo-app/config.env ]; then
            echo "ERROR: Configuration file not found"
            exit 1
          fi
          
          # Check if Docker is running
          if ! systemctl is-active --quiet docker; then
            echo "ERROR: Docker is not running"
            exit 1
          fi
          
          # Check if port 8080 is available
          if netstat -tuln | grep -q ':8080 '; then
            echo "WARNING: Port 8080 is already in use"
          fi
          
          echo "Configuration validation passed"
          exit 0
        dest: /usr/local/bin/validate-config.sh
        mode: '0755'
    
    - name: Validate configuration
      command: /usr/local/bin/validate-config.sh
      register: validation
      changed_when: false
      failed_when: validation.rc != 0
    
    - name: Enable and start demo application service
      systemd:
        name: demo-app
        state: started
        enabled: yes
        daemon_reload: yes
    
    - name: Wait for application to be ready
      wait_for:
        port: 8080
        delay: 5
        timeout: 60
        state: started
    
    - name: Test application endpoint
      uri:
        url: "http://localhost:8080/health"
        method: GET
        status_code: 200
      register: health_check
      retries: 5
      delay: 10
      until: health_check.status == 200
  
  handlers:
    - name: Reload systemd
      systemd:
        daemon_reload: yes

- name: Trigger OpenShift Deployment
  hosts: localhost
  connection: local
  gather_facts: no
  become: no
  
  tasks:
    - name: Display deployment trigger information
      debug:
        msg:
          - "========================================="
          - "Triggering OpenShift Deployment"
          - "========================================="
          - "Namespace: {{ openshift_namespace }}"
          - "Application: {{ application_name }}"
          - "Replicas: {{ replicas }}"
          - "Backend Instances: {{ instances | length }}"
    
    - name: Launch OpenShift deployment job
      ansible.builtin.debug:
        msg: "Would launch OpenShift deployment job with terraform_run_id={{ terraform_run_id }}"
      # TODO: Replace with proper job template launch once awx.awx collection is available
      # awx.awx.job_launch:
      #   job_template: "Deploy to OpenShift"
      #   extra_vars:
      #     terraform_run_id: "{{ terraform_run_id }}"
      #     terraform_workspace: "{{ terraform_workspace }}"
      #     vpc_id: "{{ vpc_id }}"
      #     aws_region: "{{ aws_region }}"
      #     instances: "{{ instances }}"
      #     openshift_namespace: "{{ openshift_namespace }}"
      #     application_name: "{{ application_name }}"
      #     replicas: "{{ replicas }}"
      #     vault_address: "{{ vault_address }}"
      #     vault_namespace: "{{ vault_namespace }}"
      # register: openshift_job
      when: openshift_namespace is defined
    
    - name: Display OpenShift job information
      debug:
        msg:
          - "OpenShift deployment job launched successfully"
          - "Job ID: {{ openshift_job.id }}"
          - "Job URL: {{ openshift_job.url }}"
      when: openshift_job is defined and openshift_job.id is defined
    
    - name: Summary of configuration
      debug:
        msg:
          - "========================================="
          - "Configuration Complete!"
          - "========================================="
          - "Terraform Run ID: {{ terraform_run_id }}"
          - "VPC ID: {{ vpc_id }}"
          - "Configured Instances: {{ instances | length }}"
          - "OpenShift Deployment: {{ 'Triggered' if openshift_job is defined else 'Skipped' }}"
          - "========================================="

# Made with Bob
